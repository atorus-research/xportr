---
title: "Deep Dive into xportr"
output: 
  rmarkdown::html_vignette:
    toc: true
    check_title: TRUE
vignette: >
  %\VignetteIndexEntry{Deep Dive into xportr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = " "
)

options(cli.num_colors = 1)

library(DT)
library(rlang)
library(haven)
```

# Introduction

This vignette will take explore in detail all the possibilities of the `{xportr}` package for applying information from a metadata object to multiple data sets using the core `{xportr}` functions. 

We will also explore the following:

* What goes in a Submission to a Health Authority?
* What is `{xportr}` validating behind the scenes?
* Breakdown of `{xportr}` and a ADaM dataset specification file.
* Using `options()` and `xportr_metadata()` to enhance your `{xportr}` experience.
* Understanding the warning and error messages for each `{xportr}` function.
* Using `{xportr}` to bulk process multiple datasets.
* Preparing xpt files for upload to a validation software.
* Future work


**NOTE:** We use the phrase _metadata object_ through out this package.  A _metadata object_ can either be a specification file read into R as a dataframe or a `{metacore}` object. The _metadata object_ created in `{metacore}` has additional features not covered here, but at its core is using a specification file. However, the intention of `{xportr}` is for it to work with either a dataframe or a `{metacore}` object.

# What goes in a Submission to a Health Authority?

Quite a bit!  We will focus on the data deliverables needed for a successful submission to a Health Authority, which we can break down into three parts: 

1) Study Data Standardization Plan
2) SDTM Data Package
3) ADaM Data Package

## Study Data Standardization Plan

The Study Data Standardization Plan (SDSP) establishes and documents a plan for describing the data standardization approach for clinical and nonclinical studies within a development program. The SDSP also assists the FDA in identifying potential data standardization issues early in the development program. We hope the brevity of this section does not belie the huge importance of this document. Please see [Study Data Standardisation Plan (SDSP) Package](https://advance.phuse.global/display/WEL/Study+Data+Standardisation+Plan+%28SDSP%29+Package) maintained by the [PHUSE working group](https://advance.phuse.global/display/WEL/Welcome+to+the+PHUSE+Advance+Hub).  However, we want to focus more on the actual data and how `{xportr}` can play a role in the submission.

## SDTM and ADaM Data Packages

__SDTM:__ The primary pieces of the SDTM package are the SDTM annotated case report forms (acrf.pdf), the data definitions document (define.xml), the Study Data Reviewer's Guide (sdrg.pdf) and the datasets in xpt Version 5 format.  The Version 5 xpt file is the **required** submission format for all datasets going to the Health Authorities.  

__ADaM:__ The key components of the ADaM package are very similar to SDTM package with a few additions: define.xml, Analysis Study Data Reviewer's Guide (adrg.pdf), Analysis Results Metadata (analysis-results-metadata.pdf) and datasets as Version 5 xpt format.

As both Data Packages need compliant `xpt` files, we feel that `{xportr}` can play a pivotal role here. The core functions in `{xportr}` can be used to apply information from the _metadata object_ to the datasets giving users feedback on the quality of the metadata and data. The `xportr_write()` can then be used to write out the final dataset as an `xpt` file that can be submitted to a Health Authority.

## What is `{xportr}` validating in these Data Packages?

The `xpt` Version 5 files form the backbone of any successful Submission and are govern by quite a lot of rules and suggested guidelines. As you are preparing your packages for submission the suite of `{xportr}` functions and `xprotr_write()` help to check that your datasets are submission compliant. The package checks many of the latest rules laid out in the [Study Data Technical Conformance Guide](https://www.fda.gov/regulatory-information/search-fda-guidance-documents/study-data-technical-conformance-guide-technical-specifications-document), but please note that it is not yet an exhaustive list of checks. We envision that users are also submitting their `xpts` and metadata to additional validation software.

Each of the core functions for applying labels, types, formats, order and lengths provide feedback to users on submission compliance. However, a final check is implemented when `xportr_write()` is called. This function calls `xpt_validate()`, which is a behind the scenes/non-exported function not available to users that does a final check for compliance.  At the time of `{xportr} v0.3` we are checking the following when a user writes out an `xpt` file.:

<img src="xpt_validate.png" alt="validate" style="width:800px;"/>


# {xportr} in action

We are going to explore the 5 core `{xportr}` functions using: 

* 5 ADaM datasets from the Pilot 3 Submission to the FDA
* ADaM Specification Files from the Pilot 3 Submission to the FDA

We will focus on warning and error messaging with contrived examples from these functions by manipulating either the datasets or the specification files.

**NOTE:** These datasets and specification are not available directly from the package. You can access them on our [repo](https://github.com/atorus-research/xportr) in the `example_data_specs` folder. This is to keep the package to a minimum size.  


## Using `options()` and `xportr_metadata()` to enhance your experience.

Before we dive into the functions, we want to point out some quality of life utilities to make your `xpt` generation life a little bit easier.

Enter...

* `options()` 
* `xportr_metadata()` 

**NOTE:** As long as you have a well-defined _metadata object_ you do NOT need to use `options()` or `xportr_metadata()`, but we find these handy to use!

## You got `options()`

`{xportr}` is built with certain assumptions around specification columns names and information in those columns.  We have found that each company specification file can differ slightly from our assumptions. The `options()` function allows users to control those assumptions inside `{xportr}` functions.

Let's take a look at our example specification files names. We can see that all the columns start with an upper case letter and have spaces in several of them. We could convert all the column names to lower case and deal with the spacing using some `{dplyr}` functions or base R or we could just use `options()`! 

```{r, message = FALSE}
library(dplyr)
library(xportr)
```
By using `options()` we are telling `{xportr}` that the following are the valid Variable names as seen below. Before we set the options the package assumed every thing was in lowercase and there were no spaces in the names.

```{r}
options(
  xportr.variable_name = "Variable",
  xportr.label = "Label",
  xportr.type_name = "Data Type",
  xportr.format = "Format",
  xportr.length = "Length",
  xportr.order_name = "Order"
)
```

## Going meta

Each of the core `{xportr}` functions require several inputs for it to work.  A valid dataframe, a metadata object and a domain name along with optional messaging. For example, here is a simple call using all of the functions. As you can see a lot of information is repeated in each call, which is redundant!     

```{r, eval = FALSE}
adsl %>%
  xportr_type(var_spec, "ADSL", "message") %>%
  xportr_length(var_spec, "ADSL", "message") %>%
  xportr_label(var_spec, "ADSL", "message") %>%
  xportr_order(var_spec, "ADSL", "message") %>%
  xportr_format(var_spec, "ADSL", "message") %>%
  xportr_write("adsl.xpt", label = "Subject-Level Analysis Dataset")
```

To help reduce these repetitive calls, we have created the `xportr_metadata()` function. A user can just **set** the _metadata object_ and the Domain name in the first call and this will be passed onto the other functions.  Much cleaner!

```{r, eval = FALSE}
adsl %>%
  xportr_metadata(var_spec, "ADSL") %>%
  xportr_type() %>%
  xportr_length() %>%
  xportr_label() %>%
  xportr_order() %>%
  xportr_format() %>%
  xportr_write("adsl.xpt", label = "Subject-Level Analysis Dataset")
```


## Warnings and Errors 

For the next six sections, we are going to explore the Warnings and Errors messages generated by `{xportr}` functions. To better explore these, we will either manipulate the ADaM dataset or specification file to help showcase the ability of the `{xportr}` functions to detect issues.  

**NOTE:** These datasets and specification are not available directly from the package. You can access them on our [repo](https://github.com/atorus-research/xportr) in the `example_data_specs` folder. This is to keep the package to a minimum size.  


```{r}
options(
  xportr.variable_name = "variable",
  xportr.label = "label",
  xportr.type_name = "type",
  xportr.format = "format",
  xportr.length = "length",
  xportr.order_name = "order"
)
```

### Setting up our metadata object

First, lets read in the specification file and call it `var_spec`.  We will also do some slight manipulation to the columns names by doing all lower case and changing `Data Type` to `type. 

```{r}
var_spec <- var_spec %>%
  dplyr::rename(type = "Data Type") %>%
  rlang::set_names(tolower)
```

```{r}
columns2hide <- c(
  "significant digits", "mandatory", "assigned value", "codelist", "common",
  "origin", "pages", "method", "predecessor", "role", "comment",
  "developer notes"
)

datatable(
  var_spec,
  rownames = FALSE,
  extensions = "Buttons", options = list(
    dom = "Bfrtip",
    columnDefs = list(list(visible = FALSE, targets = columns2hide))
  )
)
```

### `xportr_type()`

We are going to explore the type column in the metadata object. A submission to a Health Authority should only have character and numeric types in the data. In the  `ADSL` data we will have several columns that are in the Data type: `TRTSDT`, `TRTEDT`, `DISONSDT`, `VISIT1DT` and `RFENDT` and we will change one variable type to a factor variable. 

```{r}
adsl <- adsl %>%
  mutate(STUDYID = as_factor(STUDYID))
```

```{r, echo = FALSE}
adsl_glimpse <- adsl %>%
  select(STUDYID, TRTSDT, TRTEDT, DISONSDT, VISIT1DT, RFENDT)
```

```{r, echo = TRUE}
glimpse(adsl_glimpse)
```

```{r, echo = TRUE}
adsl_type <- xportr_type(adsl, var_spec, "ADSL", verbose = "warn")
```

```{r, echo = FALSE}
adsl_type_glimpse <- adsl_type %>%
  select(STUDYID, TRTSDT, TRTEDT, DISONSDT, VISIT1DT, RFENDT)
```

Success! As we can see below the `xportr_type()` function applied the types from the metadata object to the below columns converting them all to the proper type.  

```{r, echo = TRUE}
glimpse(adsl_type_glimpse)
```

Note that the `xportr_type(verbpse = "warn")` was set so the function has provided feedback, which would show up in the console, on which variables were converted as a warning message. However, you can set `verbose = 'stop'` so that the types are not applied as the data does not match what is in the specification file. 

```{r, echo = TRUE, error = TRUE}
adsl_type <- xportr_type(adsl, var_spec, "ADSL", verbose = "stop")
```

### `xportr_length()`

TODO: There is no warning around the length in the metadata being greater than 200.
TODO: There is no message to users about how many lengths were applied to the dataframe.


```{r, eval = FALSE}

var_spec_len <- var_spec %>%
  mutate(length = if_else(variable == "STUDYID", "222", length))

adsl_len <- xportr_length(adsl, var_spec_len, "ADSL", verbose = "message")
```

### `xportr_label()`

TODO: Incorrect label applied, but label still applied along with 48 other lables.  We should give user feedback on the labels still being applied.

TODO: Incorrect label applied, none and message still give warning when I have asked it not to do that.

TODO: Weird characters in outputs.  

```{r, echo = TRUE}

var_spec_lbl <- var_spec %>%
  mutate(label = if_else(variable == "TRTSDT",
    "Length of variable label must be 40 characters or less", label
  ))

adsl_lbl <- xportr_label(adsl, var_spec_lbl, "ADSL", verbose = "warn")
```

### `xportr_order()`

TODO: I think there is something wrong with `xportr_order` as it is reordering the entire dataframe to something I don't fully understand.  

TODO: What about a check on have a non-numeric value in the ordering column? I put an X in there and it did not care.

```{r}

var_spec_ord <- var_spec %>%
  mutate(order = if_else(variable == "TRTSDT", "X", order))

adsl_ord <- xportr_order(adsl, var_spec, "ADSL", verbose = "warn")
```

### `xportr_format()`

TODO: No warning issue for incorrect format type.  I put in a "DATA" format and it applied the format even though it is not a valid one.

```{r}

var_spec_fmt <- var_spec %>%
  mutate(format = if_else(variable == "TRTSDT", "DATA", format))


adsl_fmt <- xportr_format(adsl, var_spec_fmt, "ADSL", verbose = "warn")
```

### `xportr_write()`

TODO: path must contain adsl.xpt in it, but does not say this in our documentation

TODO: xpt_validate catches my DATA format, but `xportr_format()` does not catch it.

TODO: I don't think `xportr_write()` works in the README and Get Started

```{r, eval=FALSE}
var_spec_wrt <- var_spec %>%
  mutate(format = if_else(variable == "TRTSDT", "DATA", format))


xportr_write(adsl, path = "/cloud/project/adsl.xpt", label = "Subject-Level Analysis Dataset", strict_checks = FALSE)
```

## Contrived Examples for Error and Warning Messages




adsl_u <- xportr_label(adsl, var_spec, "ADSL", verbose = "warn")
```


## Warnings around label length
